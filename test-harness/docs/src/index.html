<html xmlns:j="jelly:core" xmlns:d="jelly:define" xmlns:l="layout" xmlns:x="jelly:xml" xmlns:jsl="jelly:jsl">
<head>
	<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1" />
	<title>JAX-WS/Tango Test Harness User Guide</title>
	<style>
		H1 {
			text-align: center;
		}
		
		PRE.cmd {
			background-color: #eee;
			border: solid 1px gray;
			font-weight: bold;
			padding: 0.2em;
		}
		
		DIV.tip {
			padding: 0.2em;
			margin: 1em;
			margin-left: 3em;
			border: 1px dashed black;
			background-color: #ddf;
		}
	</style>
</head>
<body>
	<!-- taglib definition -->
  <d:taglib uri="layout">
  	<!-- command example -->
	  <d:tag name="harness-cmd">
	  	<pre class="cmd">$$ java${jvmargs} -jar path/to/harness.jar <d:invokeBody /></pre>
	  </d:tag>
  	<!-- "not yet" icon -->
	  <d:tag name="not-yet">
	  	<span style="color:red; font-weight:bold">(not yet implemented)</span>
	  </d:tag>
	  <!-- box that shows a tip -->
	  <d:tag name="tip">
	  	<div class=tip>
	  		<table><tr>
	  			<td>
			  		<img src=tip.png>
			  	</td><td>
				  	<d:invokeBody />
					</td>
				</tr></table>
		  </div>
	  </d:tag>
	  <!-- section marker -->
	  <d:tag name="section">
			<j:set var="sectionNumber" value="${sectionNumber+1}" scope="parent" />
			<j:set var="prefix" value="${prefix}${sectionNumber}." />
			<j:set var="sectionNumber" value="0" /> <!-- start a new sequence for children -->
			
			<!-- name escaped for anchor and file names -->
			<j:set var="safeName" value="${title.replaceAll('[^A-Za-z0-9]','_')}" />
			
			<j:choose>
				<j:when test="${mode=='toc'}">
					<!-- generate XML fragment for TOC -->
					<TOC href="${safeName}" title="${title}">
						<d:invokeBody />
					</TOC>
				</j:when>
				<j:otherwise>
					<a name="${safeName}">
						<x:element name="h${depth+2}">
							<a href="#${safeName}">${prefix}</a> ${title}
						</x:element>
					</a>
					
					<j:set var="depth" value="${depth+1}" />
			  	<d:invokeBody />
					<j:set var="depth" value="${depth-1}" />
				</j:otherwise>
			</j:choose>
	  </d:tag>
	  <d:tag name="document">
	  	<x:parse var="tocTree">
	  		<j:scope>
	  			<ROOT>
			  		<j:set var="mode" value="toc" />
			  		<d:invokeBody />
			  	</ROOT>
		  	</j:scope>
	  	</x:parse>
	  	<jsl:stylesheet var="tocStylesheet">
	  		<jsl:template match="TOC">
	  			<x:set var="href" select="string(@href)" />
	  			<x:set var="title" select="string(@title)" />
	  			<li><a href="#${href}">${title}</a></li>
	  			<ol>
	  				<jsl:applyTemplates select="TOC" />
	  			</ol>
	  		</jsl:template>
	  	</jsl:stylesheet>
	  	<h2>Table of contents</h2>
	  	<ol>
	  		<jsl:style stylesheet="${tocStylesheet}" select="$tocTree" />
	  	</ol>
	  	<d:invokeBody />
	  </d:tag>
	</d:taglib>










<h1>JAX-WS/Tango Test Harness User Guide</h1>

<l:document>

<l:section title="Running Tests">
	<l:section title="Configuring the Harness Classpath for Different Delivery Vehicles">
		<p>
			The harness can be used to test different projects that use the JAX-WS RI.
		</p>
		<l:section title="JAX-WS RI Workspace">
			<p>
				The following option tells the harness to pick up the JAX-WS RI
                                classes from the JAX-WS workspace. Specifically, with this option,
                                the harness will look into various <tt>build/classes</tt> and library
                                jars.
			</p>
			<l:harness-cmd>-cp:jaxws path/to/jaxws-ri-workspace test-dir1 test-dir2 ...</l:harness-cmd>
		</l:section>
		<l:section title="JAX-WS RI Binary Image">
			<p>
				The following option tells the harness to pick up the
                                RI classes from a JAX-WS binary dist image. Using this option,
                                the harness will only look at the RI library jars found under
                                the <TT>lib</TT> directory of the top-level dist image directory that
                                you specify.
			</p>
			<l:harness-cmd>-cp:jaxws-image path/to/jaxws-ri-image test-dir1 test-dir2 ...</l:harness-cmd>
		</l:section>
		<l:section title="WSIT Workspace">
			<p>
				The following option tells the harness to pick up the WSIT
                                classes from a WSIT workspace. Specifically, with this option,
                                the harness will look into various <tt>build/classes</tt> and library
                                jars.
			</p>
			<l:harness-cmd><span style="color:red; font-weight:bold">-cp:wsit path/to/wsit-workspace</span> test-dir1 test-dir2 ...</l:harness-cmd>
		</l:section>
		<l:section title="WSIT Binary Image">
			<p>
				The following option tells the harness to pick up the
                                WSIT classes from a binary dist image. Using this option,
                                the harness will only look at the WSIT library jars (webservices.jar & 
                                webservices-tools.jar) found under the <TT>lib</TT> directory of the
                                dist image directory that you specify.
			</p>
			<l:harness-cmd>-cp:wsit-image path/to/wsit-image test-dir1 test-dir2 ...</l:harness-cmd>
		</l:section>
	</l:section>
	
	<l:section title="Running Tests Manually">
		<p>
			Each test is packaged in a directory. The following command runs a single test stored in <tt>testdata/abc/def</tt>:
		</p>
		<l:harness-cmd>testdata/abc/def</l:harness-cmd>
		<p>
			If you specify multiple directories, all the tests in the specified directories are run.
		</p>
		<l:harness-cmd>testdata/abc/*</l:harness-cmd>
		<p>
			The <tt>-r</tt> option tells the harness to recursively search for all tests inside the given directory:
		</p>
		<l:harness-cmd>-r testdata/addressing</l:harness-cmd>
		<l:tip>
			Consider defining an alias to <tt>java -jar path/to/harness.jar</tt> or a wrapper shell script so that you don't have to type the path name manually.
		</l:tip>
	</l:section>
	
	<l:section title="Debugging Test Failures">
		<p>
			The following command executes a test with debugger support enabled. Run this command from a console, then set up a remote debugging with your IDE to port 8000. This allows you to set breakpoints anywhere both on the client and the server.
		</p>
		<l:harness-cmd jvmargs=" -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000">testdata/abc/def</l:harness-cmd>
		<l:tip>
			You'll use this command very often, so consider defining an alias to <tt>java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,address=8000 -jar path/to/harness.jar</tt>
		</l:tip>
		<p>
			If your test data resides in the Tango workspace or the JAX-WS workspace, the harness recognizes their directory layouts and pick up classes from respective <tt>build/class</tt> directories and libraries. So if you make a change to the source code, all you need to do is to compile them to class files.
		</p>
		<l:tip>
			Do not run any targets that generate jar files, as those unnecessary work will slow you down.
		</l:tip>
		<p>
			If your change to the code is to the runtime and does not affect the code generation, then use the <tt>-skip</tt> option to skip the code generation. This allows you to quickly rerun the runtime portion of the tests without wasting time running all the tools just to produce the same results.
		<l:harness-cmd>-skip testdata/abc/def</l:harness-cmd>
	</l:section>
	
	<l:section title="Testing Different Transports/Containers">
		<p>
			The harness can run tests by using a variety of transports and containers.
		</p>
		<l:section title="local">
			<p>
				By default, the test harness uses the local transport. There's no additional option required for this mode.  This is the preferred mode of testing because of its quick turn-around time. This mode also allows you to use a single debug session to debug both the client and the server side.
			</p>
		</l:section>
		<l:section title="Tomcat">
			<p>
				This test harness supports Tomcat 5.0.x or 5.5.x. There are a few different ways of using Tomcat.
			</p>
			<l:section title="Embedded Tomcat">
				<p>
					The following command causes the harness to run Tomcat within the same VM. This mode is bit like the local transport, in the sense that both the server and the client runs inside the same VM, but this mode run tests by using HTTP and full servlet container.
				</p>
				<l:harness-cmd>-tomcat-embedded path/to/tomcat test-dir1 test-dir2 ...</l:harness-cmd>
				<p>
					<tt>path/to/tomcat</tt> should point to the directory where you have Tomcat installed. The harness will load Tomcat jar files from there.
				<p>
					This mode is preferrable mode of testing for Tomcat, as this provides the quickest turn-around time, and worry-free. This mode is the only mode in Tomcat where you can use a single debug session to debug both the client and the server.
				</p>
			</l:section>
			<l:section title="Remote Tomcat">
				<p>
					The following command causes tests to run by using Tomcat launched externally. The parameter to the -tomcat-remote option is <tt><i>adminUserName</i>:<i>adminPassword</i>@<i>hostname</i>:<i>port</i></tt>.
				</p>
				<l:harness-cmd>-tomcat-remote admin:admin@localhost:8080 test-dir1 test-dir2 ...</l:harness-cmd>
				<p>
					It is your responsibility to launch Tomcat. In this mode, the harness will only deploy and undeploy services from this running instance.
					The tomcat used for this purpose should <b>NOT</b> have JAX-WS/Tango binaries installed in <tt>common/lib</tt> or anywhere else. The harness will include everything necessary into a war file, and this is the only way to make sure that you are testing the bits that you are supposed to be testing.
				</p>
				<l:tip>
					To find out the admin username and password, look at <tt>$TOMCAT_HOME/conf/tomcat-users.xml</tt> and find the entry that has "manager" as one of the roles. If none is found, simply add the following two lines to the file:
<pre><xmp>
<role rolename="manager"/>
<user username="admin" password="admin" roles="manager"/>
</xmp></pre>
				</l:tip>
				<l:tip>
					To debug the server side in this set up, you need to launch Tomcat with the debugger support enabled. Run <tt>catalina.sh jpda run</tt> to do this, and you can attach your debugger to Tomcat remotely.
				</l:tip>
				<l:tip>
					(Tomcat 5.0.x only) By default, Tomcat is configured to output logs to multiple places, including files in the <tt>logs</tt> directory and stdout/stderr. This is often inconvenient for debugging, as you are not sure which file you should monitor. You can modify <tt>$TOMCAT_HOME/conf/server.xml</tt> to avoid this problem, by sending all the outputs to stdout. To do so, find all "&lt;Logger>" elements in server.xml and replace them with <tt>SystemOutLogger</tt>, like this:
					<pre>&lt;Logger className="org.apache.catalina.logger.SystemOutLogger" /></pre>
				</l:tip>
				<l:tip>
					When tests are aborted via Ctrl+C, web applications may be left running on this remote machine. When the test is run next time, they will be removed (or you can remove them manually.)
				</l:tip>
			</l:section>
			<l:section title="Local Tomcat">
				<p>
					Run the following command to use Tomcat in the local mode. In this mode, the haress launches Tomcat as a child process, run tests, and terminates Tomcat when everything is done.
				</p>
				<l:harness-cmd>-tomcat-local path/to/tomcat test-dir1 test-dir2 ...</l:harness-cmd>
				<p>
					See the tips for the remote tomcat support for how to configure Tomcat to report logs to one place.
				</p>
				<l:tip>
					On Windows systems, aborting the harness via Ctrl+C will leave the child Tomcat process running (does anyone know how to fix that?) Those orphan processes can be killed from task manager (be careful not to kill other Java processes), or better yet, <a href="http://www.sysinternals.com/Utilities/ProcessExplorer.html">process explorer</a>.
				</l:tip>
			</l:section>
		</l:section>
		<l:section title="Glassfish">
			<p>
				To test with Glassfish, use the following option. This mode assumes that you have already started a domain, and the harness will simply deploy/undeploy applications to this running service:
			</p>
			<l:harness-cmd>-glassfish-remote localhost test-dir1 test-dir2 ...</l:harness-cmd>
			<p>
				The "-glassfish-remote" takes the connection string as the parameter. The full syntax of the paramter is <tt>[USER:PASS@]HOST[:PORT][-HTTPURL]</tt>. The first four parts up to '-' specifies the Glassfish admin port. USER and PASS is used for the administrator login, and PORT is the admin TCP port. The last HTTPURL specifies the URL with which client test programs talk to the service. All components but HOST are defaulted, so if your glassfish installation is out of the box, then all you need to specify is the host name where Glassfish runs.
			</p>
			<l:tip>
				Glassfish has its copy of JAX-WS, so testing with Glassfish requires us to replace the runtime of Glassfish. At this point the harness is not capable of doing that.
			</l:tip>
		</l:section>
	</l:section>
	<l:section title="Running Batch Tests">
		<p>
			There are a few command-line options that often go with automated batch test for a large number of tests. First, use <tt>-p N</tt> to run tests by using N number of threads. This should be used on a multi-processor system to reduce the turn-around time of the test, and ideal for continuous testing.
		<p>
			The <tt>-report DIR</tt> option causes the harness to generate JUnit test report files into the specified directory. These generated XML reports can be then formatted into HTML (via &lt;junitreport> ant task) or picked up by Hudson.
		</p>
	</l:section>
</l:section>
<l:section title="Writing Tests">
    <l:section title="Conventions">
        <p>
            - test-descriptor.xml for each test directory
        </p>
        <p>
            - test clients are written in beanshell
            reside in top-level directory of each test
            scripts should end with suffix: .bsh
        </p>
        <p>
            - optionally, client beanshell code can be written inline in the <client> of the test descriptor
        </p>
        <p>
            - service code assumed to be all .java files in test's basedir
            basedir defaults to top-level directory, basedir specified in <service> element
        </p>
        <p>
            - 'resources' directory - automatically made available in beanshell
        </p>
        <p>
            - custom-server.xml, custom-client.xml, custom-schema-server.xml, custom-client-schema.xml
            'client' files in top-level
            'server' files in basedir of service (default is top-level unless specified in test-descriptor.xml)
        </p>
        <p>
            - schemas (*.xsd) automatically picked up from basedir of service
        </p>
    </l:section>
    <l:section title="Magic">
        <p>
            - picks up binding info from impl class
        </p>
        <p>
            - generates deployment descriptor (sun-jaxws.xml)
        </p>
        <p>
            - generates basic customization files for client and service for wsdl (not needed for for java case)
        </p>
        <p>
            - injects service, port, etc objects into script namespace automatically, don't need to be declared or instantiated
        </p>
        <p>
            - also, script inherits from junit Assert, get assertEquals(), etc for free
        </p>
    </l:section>
    <l:section title="Tips &amp; Gotchas">
        <p>beanshell script code should use the injected port & service objects rather than explicitly 
        creating them</p>
        <p>beanshell can't handle Java generic's syntax with &lt; type &gt; syntax.  Simply omit the... </p>
    </l:section>
</l:section>
</l:document>
</body>
</html>
